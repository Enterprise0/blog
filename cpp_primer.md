<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [第3章 字符串、向量和数组](#第3章-字符串向量和数组)
- [第4章 表达式](#第4章-表达式)
- [第5章 语句](#第5章-语句)
- [第6章 函数](#第6章-函数)
- [第7章 函数](#第7章-函数)
- [第12章 动态内存](#第12章-动态内存)

<!-- /code_chunk_output -->



# 第3章 字符串、向量和数组
----
- 不能在范围for循环里给vector添加元素
>范围for语句体内不应该改变其所遍历序列的大小

- 泛型编程：习惯使用`==`，`!=`（而不是>或<）和迭代器（而不是下标），这种编程风格在标准库提供的所有容器上都有效。

- vector和string的下标索引是size_type无符号类型，数组下标索引不是无符号类型。

- 尽量使用标准库类型vector、string和迭代器等，避免使用内置数组、指针和C风格的基于数组的字符串，更安全。

# 第4章 表达式
----
- 除非必须，否则不用递增递减运算符的后置版本。

- 四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast。避免强制类型转换。

# 第5章 语句
----
- break语句作用于最近的循环或者switch。
  continue语句作用域最近的循环。

- 编写异常安全（exception safe）的代码非常困难：异常中断了程序的正常执行，在异常发生期间正确执行了“清理”工作的程序被成为异常安全的代码。
  必须时刻清楚异常何时发生，异常发生后程序应如何确保对象有效、资源无泄漏、程序处于合理状态等。

# 第6章 函数
----
- 使用引用避免拷贝：拷贝大的类类型对象或者容器对象比较低效，甚至有些类类型（包括IO类型）根本不支持拷贝操作。
  尽量使用常量引用。

- 使用引用形参返回额外信息，或者返回vector或类。

- initializer_list形参，实参数量未知但类型相同可以用，对象中的元素是常量。

- 省略符形参仅仅用于C和C++通用的类型，大多数类类型对象在传递给省略符形参时无法正确拷贝。

- 不要返回局部对象的引用或指针，函数完成后局部对象被释放。

- 引用返回左值：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数返回左值，其他返回类型得到右值。

- 返回数组指针的函数形式：Type (*func(param_list))[dimension]

- 尾置返回类型

- 函数指针：声明一个指向函数的指针，只需要用指针替换函数名即可。

- 返回指向函数的指针：Type (*func(param_list))(param_list)

# 第7章 函数
----
- const常量成员函数：修改隐式this指针的类型为const。
>常量对象和常量对象的引用或指针都只能调用常量成员函数。

- mutable类型永远不会是const，即使它是const对象的成员。

- 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。

- explicit构造函数只能用于直接初始化。

- 类的静态成员和静态成员函数（static关键字只出现在类内部的声明语句中）不与任何对象绑定在一起，它们不包含this指针。静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。
  必须在类的外部定义和初始化每个静态成员（一般在对应源文件）。如果静态成员是constexpr类型，则可以在类内初始化（也应该在类外定义）。

# 第12章 动态内存
----
- 静态内存：保存局部static对象、类static数据、定义在任何函数之外的变量。
  栈内存：保存定义在函数内的非static对象。
  动态内存（在堆heap上存储）：存储在程序运行时分配的对象。
>上述内存中的对象由编译器自动创建和销毁。

- 智能指针`shared_ptr`和`unique_ptr`，不用手动管理动态内存。