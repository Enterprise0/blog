# 第一部分
----

## 第一章 温故而知新
----

### 计算机软件体系结构

- 内核提供系统调用（system call），运行时库（runtime library）提供操作系统API。系统调用接口往往以软件中断的方式实现，需要陷入内核。

### 硬盘的结构

- 硬盘的基本存储单位为扇区（sector），每个扇区一般为512字节。

- 硬盘有多个盘片，每个盘片分两面，每面按照同心圆划分为若干个磁道，每个磁道划分为若干个扇区。

- 为了屏蔽复杂的硬件细节，现代硬盘使用逻辑扇区号（Logical Block Address,LBA）的方式，整个扇区从0开始编号，一直到最后一个扇区。


### 线程

- linux中并不存在真正意义的线程概念，将所有的执行实体（进程和线程）称为任务。`fork`产生新任务的速度非常快，因为它不复制原任务的内存空间，而是共享一个`写时复制`的内存空间。

- 线程安全：将各个线程对同一数据的访问`同步`，即在一个线程访问数据未结束时，其他线程不得访问同一数据。最常见的方法是使用`锁（lock）`。
    1. N元信号量（semaphore）：在整个系统可以被任意线程获取（acquire）并释放（realease）。
    2. 互斥量（mutex）：哪个线程获取锁，哪个线程负责释放。
    3. 临界区（critical section）：信号量和互斥量在系统的任何进程里都是可见的，临界区只能在本进程可见。
    4. 读写锁：对于读写频繁，偶尔写入的情况，上面3种锁非常低效。

- 可重入（reentrant）：一个函数被重入，表示还没执行完成，由于多线程同时执行或函数调用自身，又一次进入该函数执行。
    1. 不使用任何（局部）静态或全局的非const变量。
    2. 不返回任何（局部）静态或全局的非const变量的指针。
    3. 仅依赖于调用方提供的参数。
    4. 不依赖任何单个资源的锁（mutex等）。
    5. 不调用任何不可重入的函数。

- 过度优化：
    1. CPU动态调度，在执行程序时为了提高效率有可能交换指令的顺序。
    2. 编译器优化，可能交换指令的执行顺序。

- 线程模型：
    1. 一对一：许多os限制了内核线程的数量，内核线程上下文切换的开销大。
    2. 多对一：几乎无限的线程数量，但是其中一个用户线程阻塞，所有的用户线程都会阻塞。
    3. 多对多


# 第二部分 静态链接
----

## 第二章 编译和链接
----

### 编译

- gcc
    ```bash
    gcc -E hello.c -o hello.i # 预编译
    gcc -S hello.i -o hello.s # 编译
    gcc -c hello.c -o hello.o # 预编译、编译、汇编
    ld # 链接
    ```

- 编译器：扫描、语法分析（生成语法树syntax tree）、语义分析（只能分析静态语义，指在编译期间可以确定的语义。动态语义在运行期间确定）、源代码优化、代码生成和目标代码优化。

- 定义在其他模块的全局变量和函数在最终运行时的绝对地址都要在链接时才能确定。

- 重定位（relocation）:重新计算各个目标的地址过程。汇编语言引入符号（symbol），汇编器每次汇编时重新计算符号的地址。

### 链接

- 链接：地址和空间分配（address and storage allocation）、符号决议（symbol resolution）和重定位。

- 运行时库（runtime library）：最常见的库，支持程序运行的基本函数的集合。一些最常用的代码编译成目标文件后打包存放。

- 地址修正的过程成为重定位，每个要被修正的地方叫一个重定位入口（Relocation Entry）。

## 第三章 目标文件里有什么
----

### 目标文件

- 可执行文件：Windows下的PE（portable executable）和Linux下的ELF（executable linkable format），都是COFF（common file format）格式的变种。还有intel/microsoft的OMF、unix a.out和ms-dos .com格式。

- 目标文件、静态链接库（static linking library，Win的`.lib`和Linux的`.a`）和动态链接库（DLL，dynamic linking library，Win的`.dll`和Linux的`.so`）都按照可执行文件格式存储。

- 目标文件以`节（section）`或`段（segment）`形式存储。文件头包含一个段表，描述各个段在文件中的偏移和属性。主要分为2种段：程序指令和程序数据。
    > 为什么要分离指令和数据？
        1. 程序的数据和指令被装载到虚拟内存中2个不同区域，可以分别标记为只读和可读写，可以防止指令被有意或无意地改写。
        2. 提高缓存的命中率，现代CPU的缓存一般被设计为指令和数据分离。
        3. 当系统中运行多个该程序的副本时，内存中只需要一份指令部分。

- 查看elf文件信息
    ```bash
    objdump -h *.o # 打印各个段的基本信息
    objdump -x *.o # 打印更多的信息，包括符号表和重定位信息等
    objdump -s *.o # 把所有段的内容以十六进制的方式打印出来
    objdump -d *.o # 反汇编
    readelf -h *.o 
    readelf -s *.o # 查看符号表
    size *.o       # 查看各个段的长度
    ```
    1. `.text`：代码段
    2. `.data`：数据段，保存已初始化的全局静态变量和局部静态变量。
    3. `.rodata`：只读数据段，保存只读变量（const）和字符串常量（有时候编译器会把字符串常量放在`.data`段）。
    4. `.bss`：给未初始化的全局变量和局部静态变量（static）预留空间，但是不分配空间。最终链接 成可执行文件再分配空间。

    > 系统保留段名以`.`为前缀，自定义段名不能使用。自定义段：在全局变量或函数前加上`__attribute__((section("name")))`

- elf magic code魔数：elf文件的最前面16字节用来标识elf文件的平台属性，最开始的4字节被称为elf文件的魔数，不同可执行文件的魔数不一样（可能不是4个字节），操作系统加载可执行文件时会确认魔数是否正确。elf文件的魔数为`0x7f 0x45 0x4c 0x46`，分别是DEL控制符和"ELF"的ascii码。

- 段表（section header table）：elf文件的段结构由段表决定，编译器、链接器和装载器按照段表来定位和访问各个段的属性。

- 重定位表(relocation table)：对于每个需要重定位的代码段和数据段，都有一个对应的重定位表，如`.rel.text`和`.rel.data`。

- 字符串表（string table）和段表字符串表（section header string table）：分别保存普通的字符串和段表中用到的字符串（段名等）。
> 通常一张表就是一个段

### 符号

- 符号表（symbol table）：在链接中，函数和变量统称为符号，每个符号都有对应的值。对于函数和变量，符号值就是它们的地址。最重要的2中符号：定义在本目标文件的全局符号和在本目标文件中引用的全局符号。

- 特殊符号：使用ld链接器生成可执行文件时，会定义很多特殊符号，可以在程序中声明（extern）和使用它们。

- c++符号修饰机制和函数签名（function signature）：后者是前者的实现，包含一个函数的信息：函数名、参数类型、所在类和命名空间等。不同编译器对于同一函数可能有不同的修饰后名称。`不同编译器之间不能互相操作的原因之一。`

- 弱符号和弱引用：`__attribute__((weak))`用于定义一个弱符号，`__attribute__((weakref))`用于定义一个弱引用。如果一个符号在所有目标文件中都是弱符号，会选择空间最大的一个。对于库来说十分有用。

### 调试信息

- gcc
    ```bash
    gcc -g # 编译时在目标文件加入调试信息 
    strp file # 去掉目标文件中的调试信息
    ```
    目标文件中会生成很多`.debuf_<name>`的段。目前elf文件采用`DWARF（debuf with arbitrary record format）`标准的调试信息格式。调试信息在目标文件和可执行文件中会占用很大空间，可能是程序大小的好几倍，在发布程序时需要删除。

- 
